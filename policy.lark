// ================================
// policy.lark (complete grammar)
// ================================

// ----- Imports & whitespace -----
%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_NUMBER    -> NUMBER
%import common.WS
%ignore WS
%ignore /#[^\n]*/

// (Optional) If you later want newline-sensitive statements,
// stop ignoring NEWLINE and structure `start` with NEWLINEs.
// %import common.NEWLINE

// ----- Reserved words as tokens -----
ARROW: "=>"
RETURN: "return"
IF: "if"
ELIF: "elif"
ELSE: "else"
END: "end"
FOR: "for"
IN: "in"
PRINT: "print"
TRUE: "true"
FALSE: "false"
AND: "and"
OR: "or"
NOT: "not"
DEF: "def"

// ----- Identifier (excludes keywords) -----
NAME: /(?!return|if|elif|else|end|for|in|print|true|false|and|or|not|def)[a-zA-Z_][a-zA-Z0-9_]*/

// ----- Program -----
start: stmt+

// ---------- Statements ----------
?stmt: assign
     | for_stmt
     | func_def
     | if_stmt
     | return_stmt
     | print_stmt
     | expr_stmt
     | lvalue_assign

assign: NAME "=" expr                      -> assign

lvalue_assign: NAME lvalue_chain ":=" expr        -> lvalue_assign


lvalue_chain: lvalue_suffix+                      // at least one hop
lvalue_suffix: "." NAME                           -> l_attr
             | "[" expr "]"                       -> l_index


for_stmt: FOR NAME IN expr [":"] block END -> for_stmt


// if / elif / else â€” allow optional ":" after keywords for ergonomics
if_stmt: IF expr [":"] block (ELIF expr [":"] block)* [ELSE [":"] block] END -> if_stmt

# Force return/print to grab the whole suffix chain
# and allow "return (expr)" for arithmetic etc.

return_stmt: RETURN (postfix | bool_or_nolit | "(" expr ")") -> return_stmt



print_stmt: PRINT "(" postfix ")"             -> print_stmt
          |  PRINT "(" expr ")"               -> print_stmt


expr_stmt: postfix_call                                     -> expr_stmt
         | bool_or_nolit                                    -> expr_stmt
         | "(" expr ")"                                     -> expr_stmt


block: stmt+                                 -> block

// ---------- Expressions ----------
?expr: or_expr

?or_expr: and_expr
        | or_expr OR and_expr               -> or_op

?and_expr: not_expr
         | and_expr AND not_expr            -> and_op

?not_expr: comparison
         | NOT not_expr                     -> not_op

?comparison: arith
           | comparison "==" arith          -> eq
           | comparison "!=" arith          -> ne
           | comparison ">"  arith          -> gt
           | comparison "<"  arith          -> lt
           | comparison ">=" arith          -> ge
           | comparison "<=" arith          -> le
           | comparison IN   arith          -> in_op

?comparison_nolit: arith_nolit
                 | arith_nolit IN arith     -> in_op
                 | arith_nolit "==" arith   -> eq
                 | arith_nolit "!=" arith   -> ne
                 | arith_nolit ">"  arith   -> gt
                 | arith_nolit "<"  arith   -> lt
                 | arith_nolit ">=" arith   -> ge
                 | arith_nolit "<=" arith   -> le


?bool_not_nolit: NOT bool_not_nolit              -> not_op
               | comparison_nolit


?bool_and_nolit: bool_not_nolit
               | bool_and_nolit AND bool_not_nolit   -> and_op


?bool_or_nolit: bool_and_nolit
              | bool_or_nolit OR bool_and_nolit      -> or_op



?arith: term
      | arith "+" term                      -> add
      | arith "-" term                      -> sub

?term: factor
     | term "*" factor                      -> mul
     | term "/" factor                      -> div

?factor: lambda_expr
       | postfix
       | "-" factor                         -> neg

// Postfix chain: calls, indexes, attributes
?postfix: atom (call_suffix | noncall_suffix)*


// split suffix so we can require a call in expr_stmt
call_suffix: "(" [arg_list] ")"              -> call
noncall_suffix: "[" expr "]"                 -> index
              | "." NAME                     -> attr

// a postfix that contains at least one call somewhere in the chain
postfix_call: atom noncall_suffix* call_suffix (call_suffix | noncall_suffix)* -> postfix


?atom_nolit: NUMBER             -> number
           | STRING             -> string
           | TRUE               -> true
           | FALSE              -> false
           | "nil"              -> nil
           | NAME               -> var
           | "(" expr ")"
           | lambda_expr

?postfix_nolit: atom_nolit (call_suffix | noncall_suffix)* -> postfix

// arithmetic for statements that won't begin with '[' or '{'
?factor_nolit: postfix_nolit
             | "-" factor_nolit              -> neg

?term_nolit: factor_nolit
           | term_nolit "*" factor_nolit     -> mul
           | term_nolit "/" factor_nolit     -> div

?arith_nolit: term_nolit
            | arith_nolit "+" term_nolit     -> add
            | arith_nolit "-" term_nolit     -> sub

lambda_expr: lambda_params ARROW lambda_body  -> lambda
lambda_params: NAME                           -> lambda_param_single
         | "(" [name_list] ")"                -> lambda_param_list

name_list: NAME ("," NAME)*                   -> name_list

lambda_body: expr                              -> lambda_body_expr
           | block END                         -> lambda_body_block



?atom: lambda_expr
     | NUMBER                               -> number
     | STRING                               -> string
     | TRUE                                 -> true
     | FALSE                                -> false
     | NAME                                 -> var
     | list_literal
     | dict_literal
     | "(" expr ")"

// ---------- Functions ----------
func_def: DEF NAME "(" [param_list] ")" block END  -> func_def
param_list: NAME ("," NAME)*

// ---------- Collections ----------
list_literal: "[" [arg_list] "]"            -> list
arg_list: expr ("," expr)*

dict_literal: "{" [dict_items] "}"          -> dict
dict_items: dict_item ("," dict_item)*
dict_item: dict_key ":" expr
dict_key: NAME                               -> key_name
        | STRING                             -> key_string

